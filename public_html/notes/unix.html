<h1>UNIX</h1>
<h2>Commands</h2>
<h3>Date</h3>
<table>
  <tr><td>Command</td><td>Action</td></tr>
  <tr><td>date</td><td>Display the current date and time</td></tr>
  <tr><td><code>
    date --date="date and time"
    date --date="Feb 2 2014"
    date --date="30 days ago"
    date --date="next Monday"
    </code>
</td><td>Take an input date and time and output it in date format</td></tr>
<tr><td><code>date +%formatter</code></td><td>Format the date according to the list of formatters here</td></tr>
</table>
<h3>Find</h3>
<table>
  <tr><td>Command</td><td>Action</td></tr>
  <tr><td>find criteria</td><td>Use the find command</td></tr>
  <tr><td><code>
    find criteria | xargs command
    find *.txt | xargs ls -l
  </code></td><td>Perform a command on the results of the find command</td></tr>
</table>
<h3>Grep</h3>
<p>Grep is used for searching the content of files.  It can be take string literals or regular expressions as search terms.</p>
<p>Basic grep command.  Find <em>literal_string</em> in filename.  File name can be a pattern for searching multiple files.  <code>grep "literal_string" filename</code></p>
<p>Match either pattern.  <code>grep -e "pattern" -e "pattern"</code></p>
<p><em>egrep</em> Extended grep.  A command that workslike <code>grep -E</code></p>
<p><em>zgrep</em> Search in compressed files</p>
<h4>Options</h4>
<p><em>-n</em> return line number of the match</p>
<p><em>-b</em> Show the position where it matched in the file (use with –o for the exact position rather than the word)</p>
<p><em>-i</em> Case insensitive</p>
<p><em>-w</em> Match full wordsonly</p>
<p><em>-r</em> Search recursively, (in current and subdirectories).</p>
<p><em>-v</em> Inverse grep for lines that do not match.</p>
<p><em>-c</em> Count the number of matched lines.  This is quicker than piping the output to wordcount.</p>
<p><em>-h</em> Hide filenames.</p>
<p><em>-l</em> Display only the file names containing a match</p>
<p><em>-o</em> Only show the match, rather than the whole line.  Useful with regular expressions.</p>
<p><em>-A n</em> Prints the matched line and the following n lines</p>
<p><em>-B n</em> Prints the matched line and the previous n lines</p>
<p><em>-A n</em> Prints the matched line and n lines either side.</p>
<p><em>-E</em> Extended regular expression (don’t need to escape as many things). <code>grep –E “expr1|expr2” filename</code></p>
<p><em>-e</em> Or. <code>grep for literal string 1 or literal string 2</code></p>
<p>Change the grep settings (for this session only) to highlight matched strings.  x;y define the foreground colour and z defines the background colour.  See http://www.arwin.net/tech/bash.php for colour options.
  <code>export GREP_OPTIONS='--color=auto'
  GREP_COLOR='x;y;z'</code>
</p>
<p><em></em></p>
<h4>Regular Expressions</h4>
<p><em>"^string"</em> Beginning with string</p>
<p><em>"string$"</em> Ending with string</p>
<p><em>".string"</em> . matches a single character except for the end of a line character.  Use with the –w option in grep to find words of certain length e.g. four character words: “....”</p>
<p><em>"c*"</em> Matches zero or more occurrences of the character before the asterisks (*).</p>
<p><em>"c\+"</em> Matches one or more occurrences of the character before the \+.  The escape character “/” is needed because “+” is an extended regular expression..</p>
<p><em>"c\?"</em> Matches zero or one occurrence of the character before \?.  The escape character “/” is needed because “?” is an extended regular expression.</p>
<p><em>"[abcdef]"</em> Match any of the characters in the character class</p>
<p><em>"[^abcdef]"</em> Match lines not contained in the character class</p>
<p><em>"[a-f]"</em> Character class matching using ranges (single characters only).</p>
<p><em>"[[:digit:]]"</em> Matches the digits 0-9</p>
<p><em>"[[:alnum:]]"</em> Matches alpha numeric characters</p>
<p><em>"[[:alpha:]]"</em> Matches alpha characters</p>
<p><em>"[[:blank:]]"</em> Matches space or tab characters</p>
<p><em>"expr\{m\}"</em> Exact m occurrence.  The expression is matched exactly m times.  The {} characters must be escaped.</p>
<p><em>"expr\{m,\}"</em> M or more occurrences.  The expression is matched m or more times.  The {} characters must be escaped.</p>
<p><em>"expr\{,m\}"</em> At least M occurrences.  The expression is matched at least m times.  The {} characters must be escaped.</p>
<p><em>"expr\{m,n\}"</em> M to n occurrences.  The expression is matched a minimum of m times and a maximum of n.  The {} characters must be escaped.</p>
<p><em>"expr1\|expr2"</em> Matches expr1 or expr2 .  The pipe character needs to be escaped.</p>
<p><em>"expr1.*expr2"</em> Match expr1 and expr2, appearing in the same order on the same line</p>
<p><em>"expr1.*expr2| expr2.*expr1"</em> Match expr1 and expr2, appearing in any order on the same line.  This can also be achieved by piping the results of a single grep command into another for the second condition e.g. grep “exp1” filename | grep “exp2”</p>
<p><em>\b</em> Word boundary.  If placed at the beginning of an expression, only words starting with the expression will be matched.  It can also be placed at the end or both. <code>“\bexp”</code></p>
<p><em>"\(expr\)"</em> Group a regular expression for using as a block, or for back references (See back reference)</p>
<p><em>"\(expr\)\n"</em> Back references group regular expressions e.g. match the expression followed by any character, then match the expression again. <code>“\(expr\).\1”</code></p>
<h3>Kill</h3>
<p><em>Kill PID</em> Kill a job with ID PID</p>
<p><strong>kill -9 `cat filename.txt`</strong> Force kill a job where the PID is stored in the file <em>filename.txt</em>.  See nohup for details about creating the file</p>
<p><strong>-9</strong> Force kill</p>
<h3>Miscellaneous</h3>
<p><strong>pwd</strong> Shows the current directory</p>
<p><strong>ls -lu</strong> Shows last accessed date rather than created date</p>
<p><strong>mkdir -p directory/subdirectory/subdirectory</strong> Make the full path</p>
<p><strong>uname</strong> Displays the UNIX version or computer name</p>
<p><strong>passwd</strong>Change the password</p>
<p><strong>ctrl D</strong> Stop the file</p>
<p><strong>ctrl C</strong> Stop the script</p>
<p><strong>ctrl u</strong> Start the line again</p>
<p><strong>r</strong> repeat the last command</p>
<p><strong>rm -f filename</strong> Force the file to be deleted without prompting</p>
<p><strong>history</strong> View the command history</p>
<p><strong>Esc ##### G</strong> Execute a command from the history using its number</p>
<p><strong>file filename</strong> View filetype information about the file</p>
<p><strong>stty erase <em>backspace</em></strong> Set errace to the backspace key</p>
<p><strong>man -k <em>keyword</em></strong> Identify the command you need</p>
<p><strong>uncompress</strong> Uncompress a file</p>
<p><strong>ls -s | sort -n</strong> Sort files by file size</p>
<p><strong>bc</strong> Basic calculator</p>
<p><strong>expr `<em>expression</em></strong> Execute the expression such as addition</p>
<p><strong>df</strong> Shows the number of blocks used on each available volume</p>
<p><strong>du</strong> Estimate the disk usage <code>du -sh</code></p>
<p><strong>su -l <em>target</em> <em>link_name</em></strong> Create a symbolic link.</p>
<p><strong>echo "body" | mailx -s "subject" -a "attachment" "email_address"</strong> Send an email</p>
<p><strong>curl url > file</strong> Get the url contents to a file</p>
<p><strong>nohup my_command > my.log 2>&1&</strong>Write the output of my_command to my.log</p>
<p><strong>virtualenv directory</strong> Create a virtual environment in a specified drectory</p>
<p><strong>echo $! > save_pid.txt</strong>Write the PID of the last process executed to a file</p>
<h3>Navigation</h3>
<p><strong>pushd path</strong>Change your current directory and store it on the virtual stack</p>
<p><strong>pushd +n</strong>Rotate the stack n times to the right</p>
<p><strong>puthd -n</strong>Rotate the stack n times to the left</p>
<p><strong>popd</strong> Remove the directory from the top of the virtual stack and change the current directory to the new top</p>
<p><strong>dirs</strong>View the virtual stack without changing it.</p>
<h3>Printing</h3>
<p>Printf is used in preference to echo because it is more portable.  Echo is only portable if you omit all flags and escape characters</p>
<p><strong>printf '%s%s' "string1" "string2"</strong> Substitute %s with the strings in order</p>
<p><strong>%s %d %b</strong> Preformatter: string, Preformatter: decimal, Preformatter: binary</p>
<p><strong>%ns</strong> Substitute for a string of length n characters</p>
<p><strong>printf</strong> Outputs to the standard output stream (stdout) </p>
<p><strong>fprintf</strong> goes to a file handle (FILE*) </p>
<p><strong>sprintf</strong> Writes to a buffer you allocated</p>
<h3>Xargs</h3>
<p><strong>command1 | xargs command2</strong>Run command2 on a list of file names created from command1</p>
<p><strong>-e</strong>turns off the end of file string (_) completely </p>
<h3>Special characters</h3>
<p><strong>\t</strong>Tab</p>
<p><strong>\n</strong>New Line</p>
<p><strong>^M</strong>Windows New line (carriage return)</p>
